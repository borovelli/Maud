package ec.es;

import ec.*;
import ec.simple.*;

import java.io.*;

import ec.util.*;

/*
 * ESEvolutionState.java
 *
 * Created: Thu Sep  7 17:27:47 2000
 * By: Sean Luke
 */

/**
 *
 * ESEvolutionState is an EvolutionState which accepts the (mu,lambda)
 * and (mu+lambda) breeding strategies found in the ec.es.MuPlusLambdaBreeder
 * and ec.es.MuCommaLambdaBreeder breeders, to do evolution-strategies style
 * evolution.
 *
 * <p>Evolution strategies breeders require a "mu" parameter and a "lambda"
 * parameter for each subpopulation.  "mu" refers to the number of parents
 * from which the new population will be built.  "lambda" refers to the
 * number of children generated by the mu parents.  Subpopulation sizes
 * will change as necessary to accommodate this fact in later generations.
 * The only rule for initial subpopulation sizes is that they must be
 * greater than or equal to the mu parameter for that subpopulation.
 *
 * <p>Earlier versions of ECJ specified that the initial subpopulation size
 * would be lambda.  This is no longer the case, as it does not jibe with
 * the traditional (and IMHO, odd) ES approach of having the initial
 * subpopulation size be *mu*, of all things.  You can now set your initial subpopulation
 * size to whatever you like, totally independent of lambda and mu, as long as it is
 * &gt;= mu.
 *
 * <p>ESEvolutionState stores mu and lambda values for each subpopulation
 * in the population, as well as comparisons.  A comparison tells you
 * if &gt;1/5, &lt;1/5 or =1/5 of the new population was better than its
 * parents (the so-called evolution strategies "one-fifth rule".
 * Although the comparisons are gathered, no mutation objects are provided
 * which actually <i>use</i> them -- you're free to use them in any mutation
 * objects you care to devise which requires them.
 *
 * <p>To do evolution strategies evolution, you need to use an ESEvolutionState
 * object, either MuCommaLambdaBreeder or MuPlusLambdaBreeder, and the
 * breeding pipelines must contain <b>exactly</b> one ESSelection object called
 * each time an individual is generated.   For example, if you're just
 * generating children by mutating a single selected individual into a child,
 * then you use the ESSelection object to pick that individual.  If you're
 * generating two children at a time by selecting two parents and crossing
 * them over, then each parent should be selected with ESSelection (and
 * in this case, you had better have a population size that's an even number!)
 * If you're generating one child at a time by selecting two parents and
 * crossing them over, then throwing away one of the children and mutating
 * the other, then you should have only <b>one</b> parent chosen through
 * ESSelection; the other might be chosen with Tournament Selection, say.
 *

 <p><b>Parameters</b><br>
 <table>
 <tr><td valign=top>breed.lambda.<i>subpop-num</i><br>
 <font size=-1>int >= 0</font></td><td>Specifies the 'lambda' parameter for the subpopulation.</td>
 </tr>
 <tr><td valign=top>breed.mu.<i>subpop-num</i><br>
 <font size=-1>int:  a multiple of "lambda"</font></td><td>Specifies the 'mu' parameter for the subpopulation.</td>
 </tr>
 </table>



 * @author Sean Luke
 * @version 1.0
 */

public class ESEvolutionState extends SimpleEvolutionState {
  public static final String P_MU = "mu";
  public static final String P_LAMBDA = "lambda";

  public int[] mu;
  public int[] lambda;

  public byte[] comparison;
  public static final byte C_OVER_ONE_FIFTH_BETTER = 1;
  public static final byte C_UNDER_ONE_FIFTH_BETTER = -1;
  public static final byte C_EXACTLY_ONE_FIFTH_BETTER = 0;

  /** Modified by multiple threads, don't fool with this */
  public int[] count;

  public void setup(final EvolutionState state, final Parameter base) {
    super.setup(state, base);

// double check that we have valid breeders
    if (!(breeder instanceof ESBreederForm))
      state.output.error("You've chosen to use Evolutionary Strategies-style Evolution, but your breeder is not in ESBreederForm.", base);
    Parameter p;

// we're not using the base

    p = new Parameter(Initializer.P_POP).push(Population.P_SIZE);
    int size = state.parameters.getInt(p, null, 1);  // if size is wrong, we'll let Population complain about it -- for us, we'll just make 0-sized arrays and drop out.

    mu = new int[size];
    lambda = new int[size];
    comparison = new byte[size];

// load mu and lambda data
    for (int x = 0; x < size; x++) {
      lambda[x] = state.parameters.getInt(ESDefaults.base().push(P_LAMBDA).push("" + x), null, 1);
      if (lambda[x] == 0) state.output.error("lambda must be an integer >= 1", ESDefaults.base().push(P_LAMBDA).push("" + x));
      mu[x] = state.parameters.getInt(ESDefaults.base().push(P_MU).push("" + x), null, 1);
      if (mu[x] == 0)
        state.output.error("mu must be an integer >= 1", ESDefaults.base().push(P_MU).push("" + x));
      else if ((lambda[x] / mu[x]) * mu[x] != lambda[x]) // note integer division
        state.output.error("mu must be a multiple of lambda", ESDefaults.base().push(P_MU).push("" + x));
    }
    state.output.exitIfErrors();
  }


  public void run(int condition) throws IOException {

    if (condition == C_STARTED_FRESH) {
      output.message("Setting up");
      setup(this, null);  // a garbage Parameter

      output.message("Initializing Generation 0");
      statistics.preInitializationStatistics(this);
      population = initializer.initialPopulation(this);
      exchanger.initializeContacts(this);

      // At this point we need to do load our population info
      // and make sure it jibes with our mu info

      // the first issue is: is the number of subpopulations
      // equal to the number of mu's?

      if (mu.length != population.subpops.length) // uh oh
        output.fatal("For some reason the number of subpops is different than was specified in the file (conflicting with Mu and Lambda storage).", null);

      // next, load our population, make sure there are no subpopulations smaller than the mu's
      for (int x = 0; x < population.subpops.length; x++) {
        if (population.subpops[0].individuals.length < mu[x])
          output.error("Subpopulation " + x + " must be a multiple of the equivalent mu (that is, " + mu[x] + ").");
      }
      output.exitIfErrors();

      // okay, our mus and lambdas are all set.
      statistics.postInitializationStatistics(this);
    } else // condition == C_STARTED_FROM_CHECKPOINT
    {
      // the last thing we didn't do
      generation++;
      output.message("Generation" + generation);
    }

    /* the big loop */

    int result = R_SUCCESS;
    while (true) {
      //output.message("Evaluate");
      statistics.preEvaluationStatistics(this);
      evaluator.evaluatePopulation(this);
      statistics.postEvaluationStatistics(this);
      if (evaluator.runComplete(this) && quitOnRunComplete) {
        output.message("Found Ideal Individual");
        break;
      }

      if (generation == numGenerations - 1) {
        result = R_FAILURE;
        break;
      }

      //output.message("Pre-Exchange");
      statistics.prePreBreedingExchangeStatistics(this);
      population = exchanger.preBreedingExchangePopulation(this);
      statistics.postPreBreedingExchangeStatistics(this);

      String exchangerWantsToShutdown = exchanger.runComplete(this);
      if (exchangerWantsToShutdown != null) {
        output.message(exchangerWantsToShutdown);
        break;
      }

      statistics.preBreedingStatistics(this);
      // We may perform garbage collection immediately before breeding
      // in the hopes that it makes nice large VM spaces for the new
      // individuals to fit into.
      if (gc && generation % gcModulo + 1 == gcModulo) {
        if (aggressivegc)
          aggressiveGC();
        else
          gc();
      }

      //output.message("Breed");
      try {
        population = breeder.breedPopulation(this);
      } catch (CloneNotSupportedException e) {
        throw new InternalError();
      } // never happens

      //output.message("Post-Exchange");
      statistics.postBreedingStatistics(this);
      statistics.prePostBreedingExchangeStatistics(this);
      population = exchanger.postBreedingExchangePopulation(this);
      statistics.postPostBreedingExchangeStatistics(this);

      if (checkpoint && generation % checkpointModulo + 1 == checkpointModulo) {
        output.message("Checkpointing");
        statistics.preCheckpointStatistics(this);
        Checkpoint.setCheckpoint(this);
        statistics.postCheckpointStatistics(this);
      }

      generation++;
      output.message("Generation " + generation);
    }

//Output.message("Finishing");
/* finish up -- we completed. */
    statistics.finalStatistics(this, result);
    finisher.finishPopulation(this, result);
    exchanger.closeContacts(this, result);
  }


  public void go() {
    if (debugState == DEBUG_INIT) {
      output.message("" + (debugNum++) + ") DEBUG: INIT" + generation);

      output.message("Setting up");
      setup(this, null);  // a garbage Parameter

      output.message("Initializing Generation 0");
      statistics.preInitializationStatistics(this);
      population = initializer.initialPopulation(this);
      exchanger.initializeContacts(this);

      // At this point we need to do load our population info
      // and make sure it jibes with our mu info

      // the first issue is: is the number of subpopulations
      // equal to the number of mu's?

      if (mu.length != population.subpops.length) // uh oh
        output.fatal("For some reason the number of subpops is different than was specified in the file (conflicting with Mu and Lambda storage).", null);

      // next, load our population, make sure there are no subpopulations smaller than the mu's
      for (int x = 0; x < population.subpops.length; x++) {
        if (population.subpops[0].individuals.length < mu[x])
          output.error("Subpopulation " + x + " must be a multiple of the equivalent mu (that is, " + mu[x] + ").");
      }
      output.exitIfErrors();

      // okay, our mus and lambdas are all set.

      statistics.postInitializationStatistics(this);
      debugState = DEBUG_EVAL;
    } else if (debugState == DEBUG_EVAL) {
      output.message("" + (debugNum++) + ") DEBUG: EVAL, Generation " + generation);
      statistics.preEvaluationStatistics(this);
      evaluator.evaluatePopulation(this);
      statistics.postEvaluationStatistics(this);
      if (evaluator.runComplete(this) && quitOnRunComplete) {
        output.message("Found Ideal Individual");
        debugState = DEBUG_FINAL_SUCCESS;
        return;
      }
      if (generation == numGenerations - 1) {
        debugState = DEBUG_FINAL_FAILURE;
        return;
      }
      debugState = DEBUG_BREED;
    } else if (debugState == DEBUG_BREED) {
      output.message("" + (debugNum++) + ") DEBUG: BREED, Generation " + generation);
      statistics.prePreBreedingExchangeStatistics(this);
      population = exchanger.preBreedingExchangePopulation(this);
      statistics.postPreBreedingExchangeStatistics(this);

      String exchangerWantsToShutdown = exchanger.runComplete(this);
      if (exchangerWantsToShutdown != null) {
        output.message(exchangerWantsToShutdown);
        debugState = DEBUG_FINAL_FAILURE;
        return;
      }

      statistics.preBreedingStatistics(this);
      // We may perform garbage collection immediately before breeding
      // in the hopes that it makes nice large VM spaces for the new
      // individuals to fit into.
      if (gc && generation % gcModulo + 1 == gcModulo) {
        if (aggressivegc)
          aggressiveGC();
        else
          gc();
      }

      try {
        population = breeder.breedPopulation(this);
      } catch (CloneNotSupportedException e) {
        throw new InternalError();
      } // never happens

      statistics.postBreedingStatistics(this);
      statistics.prePostBreedingExchangeStatistics(this);
      population = exchanger.postBreedingExchangePopulation(this);
      statistics.postPostBreedingExchangeStatistics(this);

      if (checkpoint && generation % checkpointModulo + 1 == checkpointModulo) {
        output.message("Checkpointing");
        statistics.preCheckpointStatistics(this);
        Checkpoint.setCheckpoint(this);
        statistics.postCheckpointStatistics(this);
      }

      generation++;
      output.message("Generation " + generation);
      debugState = DEBUG_EVAL;
    } else if (debugState == DEBUG_FINAL_SUCCESS ||
            debugState == DEBUG_FINAL_FAILURE) {
      output.message("" + (debugNum++) + ") DEBUG: FINAL.  Cleaning up.");
      int result = (debugState == DEBUG_FINAL_SUCCESS ?
              R_SUCCESS : R_FAILURE);
      statistics.finalStatistics(this, result);
      finisher.finishPopulation(this, result);
      exchanger.closeContacts(this, result);
      output.flush();
      debugState = DEBUG_END;
    } else // debugState==DEBUG_END
    {
      output.message((debugNum++) + ") DEBUG: END.  Nothing more to do.");
    }
  }
}
