<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Oct 10 18:00:46 EDT 2002 -->
<TITLE>
: Class  GPNode
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../ec/gp/GPInitializer.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../ec/gp/GPNodeBuilder.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GPNode.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
ec.gp</FONT>
<BR>
Class  GPNode</H2>
<PRE>
java.lang.Object
  |
  +--<B>ec.gp.GPNode</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable, <A HREF="../../ec/gp/GPNodeParent.html">GPNodeParent</A>, <A HREF="../../ec/Prototype.html">Prototype</A>, java.io.Serializable, <A HREF="../../ec/Setup.html">Setup</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../ec/gp/ADF.html">ADF</A>, <A HREF="../../ec/gp/ADFArgument.html">ADFArgument</A>, <A HREF="../../ec/gp/ERC.html">ERC</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>GPNode</B><DT>extends java.lang.Object<DT>implements <A HREF="../../ec/gp/GPNodeParent.html">GPNodeParent</A></DL>

<P>
GPNode is a GPNodeParent which is the abstract superclass of
 all GP function nodes in trees.  GPNode contains quite a few functions
 for cloning subtrees in special ways, counting the number of nodes
 in subtrees in special ways, and finding specific nodes in subtrees.

 GPNode's protoClone() method does not clone its children (it copies the
 array, but that's it).  If you want to deep-clone a tree or subtree, you
 should use one of the cloneReplacing(...) methods instead.

 <p>GPNodes contain a number of important items:
 <ul><li>A <i>constraints</i> object which defines the name of the node,
 its arity, and its type constraints. This
 object is shared with all GPNodes of the same function name/arity/returntype/childtypes.
 <li>A <i>parent</i>.  This is either another GPNode, or (if this node
 is the root) a GPTree.
 <li>Zero or more <i>children</i>, which are GPNodes.
 <li>An argument position in its parent.
 </ul>

<p><b>Parameters</b><br>
<table>
<tr><td valign=top><i>base</i>.<tt>nc</tt><br>
<font size=-1>String</font></td>
<td valign=top>(name of the node constraints for the GPNode)</td></tr>
</table>

<p><b>Default Base</b><br>
gp.node
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../serialized-form.html#ec.gp.GPNode">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#argposition">argposition</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The argument position of the child in its parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#children">children</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#constraints">constraints</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The GPNode's constraints.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#GPNODEPRINTTAB">GPNODEPRINTTAB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#MAXPRINTBYTES">MAXPRINTBYTES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_ALL">NODESEARCH_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_CUSTOM">NODESEARCH_CUSTOM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_NONTERMINALS">NODESEARCH_NONTERMINALS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_TERMINALS">NODESEARCH_TERMINALS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#P_NODE">P_NODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#P_NODECONSTRAINTS">P_NODECONSTRAINTS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNodeParent.html">GPNodeParent</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#parent">parent</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The GPNode's parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#REPLACEMENT_CHAR">REPLACEMENT_CHAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#SITUATION_MUTATION">SITUATION_MUTATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#SITUATION_NEWIND">SITUATION_NEWIND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#GPNode()">GPNode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#atDepth()">atDepth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the depth at which I appear in the tree, which is a value >= 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#checkConstraints(ec.EvolutionState, int, ec.gp.GPIndividual, ec.util.Parameter)">checkConstraints</A></B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                 int&nbsp;tree,
                 <A HREF="../../ec/gp/GPIndividual.html">GPIndividual</A>&nbsp;typicalIndividual,
                 <A HREF="../../ec/util/Parameter.html">Parameter</A>&nbsp;individualBase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You ought to override this method to check to make sure that the
constraints are valid as best you can tell.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacing()">cloneReplacing</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacing(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacing</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;newSubtrees,
               <A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;oldSubtrees)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacing(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacing</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newSubtree,
               <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingAtomic(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacingAtomic</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;newNodes,
                     <A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;oldNodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones a new subtree, but with each node in oldNodes[] respectively
(which may or may not be in the subtree) replaced with
the equivalent
nodes in newNodes[] (and not clones).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingAtomic(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingAtomic</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newNode,
                     <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones a new subtree, but with the single node oldNode 
(which may or may not be in the subtree) 
replaced with a newNode (not a clone of newNode).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingAtomicSimple(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacingAtomicSimple</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;newNodes,
                           <A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;oldNodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones a new subtree, but with each node in oldNodes[] respectively
(which may or may not be in the subtree) replaced with
the equivalent
nodes in newNodes[] (and not clones of them).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingAtomicSimple(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingAtomicSimple</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newNode,
                           <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones a new subtree, but with the single node oldNode 
(which may or may not be
in the subtree) replaced with newNode (not a clone of newNode).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingNoSubclone(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingNoSubclone</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newSubtree,
                         <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingNoSubcloneSimple(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingNoSubcloneSimple</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newSubtree,
                               <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingSimple()">cloneReplacingSimple</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingSimple(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacingSimple</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;newSubtrees,
                     <A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;oldSubtrees)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingSimple(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingSimple</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newSubtree,
                     <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNodeConstraints.html">GPNodeConstraints</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#constraints()">constraints</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#contains(ec.gp.GPNode)">contains</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;subnode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the subtree rooted at this node contains subnode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/util/Parameter.html">Parameter</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#defaultBase()">defaultBase</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The default base for GPNodes -- defined even though
GPNode is abstract so you don't have to in subclasses.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#depth()">depth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the depth of the tree, which is a value >= 1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#errorInfo()">errorInfo</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A convenience function for identifying a GPNode in an error message</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#eval(ec.EvolutionState, int, ec.gp.GPData, ec.gp.ADFStack, ec.gp.GPIndividual, ec.Problem)">eval</A></B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
     int&nbsp;thread,
     <A HREF="../../ec/gp/GPData.html">GPData</A>&nbsp;input,
     <A HREF="../../ec/gp/ADFStack.html">ADFStack</A>&nbsp;stack,
     <A HREF="../../ec/gp/GPIndividual.html">GPIndividual</A>&nbsp;individual,
     <A HREF="../../ec/Problem.html">Problem</A>&nbsp;problem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evaluates the node with the given thread, state, individual, problem, and stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#makeLatexTree()">makeLatexTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Produces the LaTeX code for a LaTeX tree of the subtree rooted at this node, using the <tt>epic</tt>
and <tt>fancybox</tt> packages, as described in sections 10.5.2 (page 307) 
and 10.1.3 (page 278) of <i>The LaTeX Companion</i>, respectively.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#nodeEquals(ec.gp.GPNode)">nodeEquals</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if I am the "genetically" same as this node, and our
children arrays are the same length, though
we may have different parents and children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#nodeHashCode()">nodeHashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a hashcode usually associated with all nodes that are 
equal to you (using nodeEquals(...)).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#nodeInPosition(int, ec.gp.GPNodeGatherer, int)">nodeInPosition</A></B>(int&nbsp;p,
               <A HREF="../../ec/gp/GPNodeGatherer.html">GPNodeGatherer</A>&nbsp;g,
               int&nbsp;nodesearch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the p'th node, constrained by nodesearch,
in the subtree for which this GPNode is root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#numNodes(ec.gp.GPNodeGatherer)">numNodes</A></B>(<A HREF="../../ec/gp/GPNodeGatherer.html">GPNodeGatherer</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of nodes, constrained by g.test(...)
in the subtree for which this GPNode is root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#numNodes(int)">numNodes</A></B>(int&nbsp;nodesearch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of nodes, constrained by nodesearch,
in the subtree for which this GPNode is root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPType.html">GPType</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#parentType()">parentType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the argument type of the slot that I fit into in my parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printNode(ec.EvolutionState, int, int)">printNode</A></B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
          int&nbsp;log,
          int&nbsp;verbosity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out a COMPUTER-readable and Lisp-like atom for the node, which
is also suitable for readNode to read, and returns
the number of bytes in the string that you sent to the log (use print(),
not println()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printNode(ec.EvolutionState, java.io.PrintWriter)">printNode</A></B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
          java.io.PrintWriter&nbsp;writer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out a COMPUTER-readable and Lisp-like atom for the node, which
is also suitable for readNode to read, and returns
the number of bytes in the string that you sent to the log (use print(),
not println()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printNodeForHumans(ec.EvolutionState, int, int)">printNodeForHumans</A></B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                   int&nbsp;log,
                   int&nbsp;verbosity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out a human-readable and Lisp-like atom for the node, 
and returns the number of bytes in the string that you sent
to the log (use print(),
not println()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printRootedTree(ec.EvolutionState, int, int, int)">printRootedTree</A></B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                int&nbsp;log,
                int&nbsp;verbosity,
                int&nbsp;printbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out the tree on a single line, with no ending \n, in a fashion that can
be read in later by computer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printRootedTree(ec.EvolutionState, java.io.PrintWriter, int)">printRootedTree</A></B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                java.io.PrintWriter&nbsp;writer,
                int&nbsp;printbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out the tree on a single line, with no ending \n, in a fashion that can
be read in later by computer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printRootedTreeForHumans(ec.EvolutionState, int, int, int, int)">printRootedTreeForHumans</A></B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                         int&nbsp;log,
                         int&nbsp;verbosity,
                         int&nbsp;tablevel,
                         int&nbsp;printbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out the tree in a readable Lisp-like multi-line fashion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#protoClone()">protoClone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new individual cloned from a prototype,
and suitable to begin use in its own evolutionary
context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#protoCloneSimple()">protoCloneSimple</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This should be implemented in a the top-level Prototype ONLY;
in fact, it should probably be declared final.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#readNode(ec.util.DecodeReturn)">readNode</A></B>(<A HREF="../../ec/util/DecodeReturn.html">DecodeReturn</A>&nbsp;dret)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the node symbol,
advancing the DecodeReturn to the first character in the string
beyond the node symbol, and returns a new, empty GPNode of the
appropriate class representing that symbol, else null if the
node symbol is not of the correct type for your GPNode class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../ec/gp/GPNode.html">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#readRootedTree(int, ec.util.DecodeReturn, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int, ec.EvolutionState)">readRootedTree</A></B>(int&nbsp;linenumber,
               <A HREF="../../ec/util/DecodeReturn.html">DecodeReturn</A>&nbsp;dret,
               <A HREF="../../ec/gp/GPType.html">GPType</A>&nbsp;expectedType,
               <A HREF="../../ec/gp/GPFunctionSet.html">GPFunctionSet</A>&nbsp;set,
               <A HREF="../../ec/gp/GPNodeParent.html">GPNodeParent</A>&nbsp;parent,
               int&nbsp;argposition,
               <A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the node and its children from the form printed out by printRootedTree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#resetNode(ec.EvolutionState, int)">resetNode</A></B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
          int&nbsp;thread)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starts a node in a new life immediately after it has been cloned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#rootedTreeEquals(ec.gp.GPNode)">rootedTreeEquals</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the two rooted trees are "genetically" equal, though
they may have different parents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#rootedTreeHashCode()">rootedTreeHashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a hashcode associated with all the nodes in the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNodeParent.html">GPNodeParent</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#rootParent()">rootParent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the root ancestor of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#setup(ec.EvolutionState, ec.util.Parameter)">setup</A></B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
      <A HREF="../../ec/util/Parameter.html">Parameter</A>&nbsp;base)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets up a <i>prototypical</i> GPNode with those features all nodes of that
prototype share, and nothing more.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#swapCompatibleWith(ec.gp.GPNode)">swapCompatibleWith</A></B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if I can swap into node's position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Lisp-like atom for the node which can be read in again by computer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#toStringForError()">toStringForError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a description of the node that can make it easy to identify
in error messages (by default, at least its name and the tree it's found in).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#toStringForHumans()">toStringForHumans</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Lisp-like atom for the node which is intended for human
consumption, and not to be read in again.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="P_NODE"><!-- --></A><H3>
P_NODE</H3>
<PRE>
public static final java.lang.String <B>P_NODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="P_NODECONSTRAINTS"><!-- --></A><H3>
P_NODECONSTRAINTS</H3>
<PRE>
public static final java.lang.String <B>P_NODECONSTRAINTS</B></PRE>
<DL>
</DL>
<HR>

<A NAME="GPNODEPRINTTAB"><!-- --></A><H3>
GPNODEPRINTTAB</H3>
<PRE>
public static final java.lang.String <B>GPNODEPRINTTAB</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MAXPRINTBYTES"><!-- --></A><H3>
MAXPRINTBYTES</H3>
<PRE>
public static final int <B>MAXPRINTBYTES</B></PRE>
<DL>
</DL>
<HR>

<A NAME="NODESEARCH_ALL"><!-- --></A><H3>
NODESEARCH_ALL</H3>
<PRE>
public static final int <B>NODESEARCH_ALL</B></PRE>
<DL>
</DL>
<HR>

<A NAME="NODESEARCH_TERMINALS"><!-- --></A><H3>
NODESEARCH_TERMINALS</H3>
<PRE>
public static final int <B>NODESEARCH_TERMINALS</B></PRE>
<DL>
</DL>
<HR>

<A NAME="NODESEARCH_NONTERMINALS"><!-- --></A><H3>
NODESEARCH_NONTERMINALS</H3>
<PRE>
public static final int <B>NODESEARCH_NONTERMINALS</B></PRE>
<DL>
</DL>
<HR>

<A NAME="NODESEARCH_CUSTOM"><!-- --></A><H3>
NODESEARCH_CUSTOM</H3>
<PRE>
public static final int <B>NODESEARCH_CUSTOM</B></PRE>
<DL>
</DL>
<HR>

<A NAME="SITUATION_NEWIND"><!-- --></A><H3>
SITUATION_NEWIND</H3>
<PRE>
public static final int <B>SITUATION_NEWIND</B></PRE>
<DL>
</DL>
<HR>

<A NAME="SITUATION_MUTATION"><!-- --></A><H3>
SITUATION_MUTATION</H3>
<PRE>
public static final int <B>SITUATION_MUTATION</B></PRE>
<DL>
</DL>
<HR>

<A NAME="parent"><!-- --></A><H3>
parent</H3>
<PRE>
public <A HREF="../../ec/gp/GPNodeParent.html">GPNodeParent</A> <B>parent</B></PRE>
<DL>
<DD>The GPNode's parent.  4 bytes.  :-(  But it really helps simplify breeding.</DL>
<HR>

<A NAME="children"><!-- --></A><H3>
children</H3>
<PRE>
public <A HREF="../../ec/gp/GPNode.html">GPNode</A>[] <B>children</B></PRE>
<DL>
</DL>
<HR>

<A NAME="argposition"><!-- --></A><H3>
argposition</H3>
<PRE>
public byte <B>argposition</B></PRE>
<DL>
<DD>The argument position of the child in its parent. 
This is a byte to save space (GPNode is the critical object space-wise) -- 
besides, how often do you have 256 children? You can change this to a short
or int easily if you absolutely need to.  It's possible to eliminate even
this and have the child find itself in its parent, but that's an O(children[])
operation, and probably not inlinable, so I figure a byte is okay.</DL>
<HR>

<A NAME="constraints"><!-- --></A><H3>
constraints</H3>
<PRE>
public byte <B>constraints</B></PRE>
<DL>
<DD>The GPNode's constraints.  This is a byte to save space -- how often do
you have 256 different GPNodeConstraints?  Well, I guess it's not infeasible.
You can increase4 this to an int without much trouble.  You typically 
shouldn't access the constraints through this variable -- use the constraints()
method instead.</DL>
<HR>

<A NAME="REPLACEMENT_CHAR"><!-- --></A><H3>
REPLACEMENT_CHAR</H3>
<PRE>
public static final char <B>REPLACEMENT_CHAR</B></PRE>
<DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="GPNode()"><!-- --></A><H3>
GPNode</H3>
<PRE>
public <B>GPNode</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="constraints()"><!-- --></A><H3>
constraints</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNodeConstraints.html">GPNodeConstraints</A> <B>constraints</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defaultBase()"><!-- --></A><H3>
defaultBase</H3>
<PRE>
public <A HREF="../../ec/util/Parameter.html">Parameter</A> <B>defaultBase</B>()</PRE>
<DL>
<DD>The default base for GPNodes -- defined even though
GPNode is abstract so you don't have to in subclasses.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../ec/Prototype.html#defaultBase()">defaultBase</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html">Prototype</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="checkConstraints(ec.EvolutionState, int, ec.gp.GPIndividual, ec.util.Parameter)"><!-- --></A><H3>
checkConstraints</H3>
<PRE>
public void <B>checkConstraints</B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                             int&nbsp;tree,
                             <A HREF="../../ec/gp/GPIndividual.html">GPIndividual</A>&nbsp;typicalIndividual,
                             <A HREF="../../ec/util/Parameter.html">Parameter</A>&nbsp;individualBase)</PRE>
<DL>
<DD>You ought to override this method to check to make sure that the
constraints are valid as best you can tell.  Things you might
check for:

<ul>
<li> children.length is correct
<li> certain arguments in constraints.childtypes are 
swap-compatible with each other
<li> constraints.returntype is swap-compatible with appropriate 
arguments in constraints.childtypes
</ul>

You can't check for everything, of course, but you might try some
obvious checks for blunders.  The default version of this method
is empty for now, but you should still call super.checkConstraints(state)
just to be certain.

The ultimate caller of this method must guarantee that he will eventually
call state.output.exitIfErrors(), so you can freely use state.output.error
instead of state.output.fatal(), which will help a lot.

Warning: this method may get called more than once.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setup(ec.EvolutionState, ec.util.Parameter)"><!-- --></A><H3>
setup</H3>
<PRE>
public void <B>setup</B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                  <A HREF="../../ec/util/Parameter.html">Parameter</A>&nbsp;base)</PRE>
<DL>
<DD>Sets up a <i>prototypical</i> GPNode with those features all nodes of that
prototype share, and nothing more.  So no filled-in children, 
no argposition, no parent.  Yet.

This must be called <i>after</i> the GPTypes and GPNodeConstraints 
have been set up.  Presently they're set up in GPInitializer,
which gets called before this does, so we're safe. 

You should override this if you need to load some special features on
a per-function basis.  Note that base hangs off of a function set, so
this method may get called for different instances in the same GPNode
class if they're being set up as prototypes for different GPFunctionSets.

If you absolutely need some global base, then you should use something
hanging off of GPDefaults.base().

The ultimate caller of this method must guarantee that he will eventually
call state.output.exitIfErrors(), so you can freely use state.output.error
instead of state.output.fatal(), which will help a lot.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../ec/Prototype.html#setup(ec.EvolutionState, ec.util.Parameter)">setup</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html">Prototype</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parentType()"><!-- --></A><H3>
parentType</H3>
<PRE>
public final <A HREF="../../ec/gp/GPType.html">GPType</A> <B>parentType</B>()</PRE>
<DL>
<DD>Returns the argument type of the slot that I fit into in my parent.  
If I'm the root, returns the treetype of the GPTree.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="swapCompatibleWith(ec.gp.GPNode)"><!-- --></A><H3>
swapCompatibleWith</H3>
<PRE>
public final boolean <B>swapCompatibleWith</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;node)</PRE>
<DL>
<DD>Returns true if I can swap into node's position.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="numNodes(ec.gp.GPNodeGatherer)"><!-- --></A><H3>
numNodes</H3>
<PRE>
public int <B>numNodes</B>(<A HREF="../../ec/gp/GPNodeGatherer.html">GPNodeGatherer</A>&nbsp;g)</PRE>
<DL>
<DD>Returns the number of nodes, constrained by g.test(...)
in the subtree for which this GPNode is root.  This might
be sped up by caching the value.  O(n).<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="numNodes(int)"><!-- --></A><H3>
numNodes</H3>
<PRE>
public int <B>numNodes</B>(int&nbsp;nodesearch)</PRE>
<DL>
<DD>Returns the number of nodes, constrained by nodesearch,
in the subtree for which this GPNode is root.
This might be sped up by cacheing the value somehow.  O(n).<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="depth()"><!-- --></A><H3>
depth</H3>
<PRE>
public int <B>depth</B>()</PRE>
<DL>
<DD>Returns the depth of the tree, which is a value >= 1.  O(n).<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="atDepth()"><!-- --></A><H3>
atDepth</H3>
<PRE>
public int <B>atDepth</B>()</PRE>
<DL>
<DD>Returns the depth at which I appear in the tree, which is a value >= 0. O(ln n) avg.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeInPosition(int, ec.gp.GPNodeGatherer, int)"><!-- --></A><H3>
nodeInPosition</H3>
<PRE>
public int <B>nodeInPosition</B>(int&nbsp;p,
                          <A HREF="../../ec/gp/GPNodeGatherer.html">GPNodeGatherer</A>&nbsp;g,
                          int&nbsp;nodesearch)</PRE>
<DL>
<DD>Returns the p'th node, constrained by nodesearch,
in the subtree for which this GPNode is root.
Use numNodes(nodesearch) to determine the total number.  Or if
you used numNodes(g), then when
nodesearch == NODESEARCH_CUSTOM, g.test(...) is used
as the constraining predicate.
p ranges from 0 to this number minus 1. O(n). The
resultant node is returned in <i>g</i>.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rootParent()"><!-- --></A><H3>
rootParent</H3>
<PRE>
public <A HREF="../../ec/gp/GPNodeParent.html">GPNodeParent</A> <B>rootParent</B>()</PRE>
<DL>
<DD>Returns the root ancestor of this node.  O(ln n) average case,
O(n) worst case.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="contains(ec.gp.GPNode)"><!-- --></A><H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;subnode)</PRE>
<DL>
<DD>Returns true if the subtree rooted at this node contains subnode.  O(n).<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resetNode(ec.EvolutionState, int)"><!-- --></A><H3>
resetNode</H3>
<PRE>
public void <B>resetNode</B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                      int&nbsp;thread)</PRE>
<DL>
<DD>Starts a node in a new life immediately after it has been cloned.
The default version of this function does nothing.  The purpose of
this function is to give ERCs a chance to set themselves to a new
random value after they've been cloned from the prototype.
You should not assume that the node is properly connected to other
nodes in the tree at the point this method is called.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="errorInfo()"><!-- --></A><H3>
errorInfo</H3>
<PRE>
public java.lang.String <B>errorInfo</B>()</PRE>
<DL>
<DD>A convenience function for identifying a GPNode in an error message<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="protoClone()"><!-- --></A><H3>
protoClone</H3>
<PRE>
public java.lang.Object <B>protoClone</B>()
                            throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../ec/Prototype.html">Prototype</A></CODE></B></DD>
<DD>Creates a new individual cloned from a prototype,
and suitable to begin use in its own evolutionary
context.

<p>The question here is whether or not this means to perform a 
"deep" or "light" ("shallow") clone, or something in-between.  
You may need to deep-clone parts of your object
rather than simply copying their references, depending
on the situation:

<p>
<ul>
<li>If you hold objects which are shared with other instances,
don't clone them.
<li>If you hold objects which must be unique, clone them.
<li>If you hold objects which were given to you as a gesture
of kindness, and aren't owned by you, you probably shouldn't clone
them.
<li> DON'T attempt to clone: Singletons, Cliques, or Groups.
<li>Arrays are not cloned automatically; you may need to
clone an array if you're not sharing it with other instances.
Arrays have the nice feature of being copyable by calling clone()
on them.
</ul>

<p><b>Implementations.</b>

<ul>
<li>If no ancestor of yours implements protoClone(),
and you have no need to either (light cloning is fine with you),
and you are abstract, then you should not declare protoClone().

<li>If no ancestor of yours implements protoClone(),
and you have no need to either (light cloning is fine with you),
and you are <b>not</b> abstract, then you should implement
it as follows:

<p>
<tt><pre>
public Object protoClone() throws CloneNotSupportedException
{ 
return super.clone();
}
</pre></tt>

<li>If no ancestor of yours implements protoClone(), but you
need to deep-clone some things, then you should implement it
as follows:

<p>
<tt><pre>
public Object protoClone() throws CloneNotSupportedException
{
myobj = (MyObject) (super.clone());

// put your deep-cloning code here...
// ...you should use protoClone and not 
// protoCloneSimple to clone subordinate objects...
return myobj;
} 
</pre></tt>

<li>If you need to override an ancestors' implementation
of protoClone, in order to do your own deep cloning as well,
then you should implement it as follows:

<p>
<tt><pre>
public Object protoClone() throws CloneNotSupportedException
{
MyObject myobj = (MyObject)(super.protoClone());

// put your deep-cloning code here...
// ...you should use protoClone and not 
// protoCloneSimple to clone subordinate objects...
return myobj;
} 
</pre></tt>

</ul>

<p>If you know that your superclasses will <i>never</i> change
their protoClone() implementations, you might try inlining them
in your overridden protoClone() method.  But this is dangerous
(though it yields a small net increase).

<p>In general, you want to keep your deep cloning to an absolute
minimum, so that you don't have to call protoClone() but
one time.

<p>The approach taken here is the fastest that I am aware of
while still permitting objects to be specified at runtime from
a parameter file.  It would be faster to use the "new" operator;
but that would require hard-coding that we can't do.  Although
using java.lang.Object.clone() entails an extra layer that
deals with stripping away the "protected" keyword and also 
wrapping the exception handling (which is a BIG hit, about
three times as slow as using "new"), it's still MUCH faster
than using java.lang.Class.newInstance(), and also much faster
than rolling our own Clone() method.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../ec/Prototype.html#protoClone()">protoClone</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html">Prototype</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="protoCloneSimple()"><!-- --></A><H3>
protoCloneSimple</H3>
<PRE>
public final java.lang.Object <B>protoCloneSimple</B>()</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../ec/Prototype.html">Prototype</A></CODE></B></DD>
<DD>This should be implemented in a the top-level Prototype ONLY;
in fact, it should probably be declared final.  It should be
implemented as follows:

<p>
<tt><pre>
public final Object protoCloneSimple()
{
try { return protoClone(); }
catch (CloneNotSupportedException e) 
{ throw new InternalError(); } // never happens
} 
</pre></tt><DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../ec/Prototype.html#protoCloneSimple()">protoCloneSimple</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html">Prototype</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacing()"><!-- --></A><H3>
cloneReplacing</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacing</B>()
                            throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
copied tree.  The result has everything set except for the root
node's parent and argposition.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingSimple()"><!-- --></A><H3>
cloneReplacingSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacingSimple</B>()</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
copied tree. The result has everything set except for the root
node's parent and argposition.
Does not throw CloneNotSupportedException.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacing(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacing</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacing</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newSubtree,
                                   <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldSubtree)
                            throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
copied tree.  If the node oldSubtree is located somewhere in this
tree, then its subtree is replaced with a deep-cloned copy of
newSubtree.  The result has everything set except for the root
node's parent and argposition.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingSimple(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacingSimple</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newSubtree,
                                         <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldSubtree)</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
copied tree.  If the node oldSubtree is located somewhere in this
tree, then its subtree is replaced with a deep-cloned copy of
newSubtree.  The result has everything set except for the root
node's parent and argposition. Does not throw
CloneNotSupportedException.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingNoSubclone(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingNoSubclone</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacingNoSubclone</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newSubtree,
                                             <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldSubtree)
                                      throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
copied tree.  If the node oldSubtree is located somewhere in this
tree, then its subtree is replaced with
newSubtree (<i>not</i> a copy of newSubtree).  
The result has everything set except for the root
node's parent and argposition.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingNoSubcloneSimple(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingNoSubcloneSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacingNoSubcloneSimple</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newSubtree,
                                                   <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldSubtree)</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
copied tree.  If the node oldSubtree is located somewhere in this
tree, then its subtree is replaced with
newSubtree (<i>not</i> a copy of newSubtree).  
The result has everything set except for the root
node's parent and argposition. Does not throw
CloneNotSupportedException.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacing(ec.gp.GPNode[], ec.gp.GPNode[])"><!-- --></A><H3>
cloneReplacing</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacing</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;newSubtrees,
                                   <A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;oldSubtrees)
                            throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
copied tree.  If a node in oldSubtrees is located somewhere in this
tree, then its subtree is replaced with a deep-cloned copy of the
subtree rooted at its equivalent number in 
newSubtrees.  The result has everything set except for the root
node's parent and argposition.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingSimple(ec.gp.GPNode[], ec.gp.GPNode[])"><!-- --></A><H3>
cloneReplacingSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacingSimple</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;newSubtrees,
                                         <A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;oldSubtrees)</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
copied tree.  If a node in oldSubtrees is located somewhere in this
tree, then its subtree is replaced with a deep-cloned copy of the
subtree rooted at its equivalent number in 
newSubtrees.  The result has everything set except for the root
node's parent and argposition. Does not throw
CloneNotSupportedException.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingAtomic(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingAtomic</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacingAtomic</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newNode,
                                         <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldNode)
                                  throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Clones a new subtree, but with the single node oldNode 
(which may or may not be in the subtree) 
replaced with a newNode (not a clone of newNode).  
These nodes should be
type-compatible both in argument and return types, and should have
the same number of arguments obviously.  This function will <i>not</i>
check for this, and if they are not the result is undefined.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingAtomicSimple(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingAtomicSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacingAtomicSimple</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;newNode,
                                               <A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;oldNode)</PRE>
<DL>
<DD>Clones a new subtree, but with the single node oldNode 
(which may or may not be
in the subtree) replaced with newNode (not a clone of newNode).  
These nodes should be
type-compatible both in argument and return types, and should have
the same number of arguments obviously.  This function will <i>not</i>
check for this, and if they are not the result is undefined.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingAtomic(ec.gp.GPNode[], ec.gp.GPNode[])"><!-- --></A><H3>
cloneReplacingAtomic</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacingAtomic</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;newNodes,
                                         <A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;oldNodes)
                                  throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Clones a new subtree, but with each node in oldNodes[] respectively
(which may or may not be in the subtree) replaced with
the equivalent
nodes in newNodes[] (and not clones).  
The length of oldNodes[] and newNodes[] should
be the same of course.  These nodes should be
type-compatible both in argument and return types, and should have
the same number of arguments obviously.  This function will <i>not</i>
check for this, and if they are not the result is undefined.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingAtomicSimple(ec.gp.GPNode[], ec.gp.GPNode[])"><!-- --></A><H3>
cloneReplacingAtomicSimple</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>cloneReplacingAtomicSimple</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;newNodes,
                                               <A HREF="../../ec/gp/GPNode.html">GPNode</A>[]&nbsp;oldNodes)</PRE>
<DL>
<DD>Clones a new subtree, but with each node in oldNodes[] respectively
(which may or may not be in the subtree) replaced with
the equivalent
nodes in newNodes[] (and not clones of them).  
The length of oldNodes[] and newNodes[] should
be the same of course.  These nodes should be
type-compatible both in argument and return types, and should have
the same number of arguments obviously.  This function will <i>not</i>
check for this, and if they are not the result is undefined.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeHashCode()"><!-- --></A><H3>
nodeHashCode</H3>
<PRE>
public int <B>nodeHashCode</B>()</PRE>
<DL>
<DD>Returns a hashcode usually associated with all nodes that are 
equal to you (using nodeEquals(...)).  The default form
of this method returns the hashcode of the node's class.
ERCs in particular probably will want to override this method.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rootedTreeHashCode()"><!-- --></A><H3>
rootedTreeHashCode</H3>
<PRE>
public int <B>rootedTreeHashCode</B>()</PRE>
<DL>
<DD>Returns a hashcode associated with all the nodes in the tree.  
The default version adds the hash of the node plus its child
trees, rotated one-off each time, which seems reasonable.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeEquals(ec.gp.GPNode)"><!-- --></A><H3>
nodeEquals</H3>
<PRE>
public boolean <B>nodeEquals</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;node)</PRE>
<DL>
<DD>Returns true if I am the "genetically" same as this node, and our
children arrays are the same length, though
we may have different parents and children.  The default form
of this method does a class comparison.  You may need
to override this to perform special comparisons, if you're
an ERC, ADF, or ADM for example.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rootedTreeEquals(ec.gp.GPNode)"><!-- --></A><H3>
rootedTreeEquals</H3>
<PRE>
public boolean <B>rootedTreeEquals</B>(<A HREF="../../ec/gp/GPNode.html">GPNode</A>&nbsp;node)</PRE>
<DL>
<DD>Returns true if the two rooted trees are "genetically" equal, though
they may have different parents.  O(n).<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printNodeForHumans(ec.EvolutionState, int, int)"><!-- --></A><H3>
printNodeForHumans</H3>
<PRE>
public int <B>printNodeForHumans</B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                              int&nbsp;log,
                              int&nbsp;verbosity)</PRE>
<DL>
<DD>Prints out a human-readable and Lisp-like atom for the node, 
and returns the number of bytes in the string that you sent
to the log (use print(),
not println()).  The default version gets the atom from
toStringForHumans().<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printNode(ec.EvolutionState, int, int)"><!-- --></A><H3>
printNode</H3>
<PRE>
public int <B>printNode</B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                     int&nbsp;log,
                     int&nbsp;verbosity)</PRE>
<DL>
<DD>Prints out a COMPUTER-readable and Lisp-like atom for the node, which
is also suitable for readNode to read, and returns
the number of bytes in the string that you sent to the log (use print(),
not println()).  The default version gets the atom from toString().
O(1).<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printNode(ec.EvolutionState, java.io.PrintWriter)"><!-- --></A><H3>
printNode</H3>
<PRE>
public int <B>printNode</B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                     java.io.PrintWriter&nbsp;writer)</PRE>
<DL>
<DD>Prints out a COMPUTER-readable and Lisp-like atom for the node, which
is also suitable for readNode to read, and returns
the number of bytes in the string that you sent to the log (use print(),
not println()).  The default version gets the atom from toString().
O(1).<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public abstract java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Returns a Lisp-like atom for the node which can be read in again by computer.
If you need to encode an integer or a float or whatever for some reason
(perhaps if it's an ERC), you should use the ec.util.Code library.<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="toStringForHumans()"><!-- --></A><H3>
toStringForHumans</H3>
<PRE>
public java.lang.String <B>toStringForHumans</B>()</PRE>
<DL>
<DD>Returns a Lisp-like atom for the node which is intended for human
consumption, and not to be read in again.  The default version
just calls toString().<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toStringForError()"><!-- --></A><H3>
toStringForError</H3>
<PRE>
public java.lang.String <B>toStringForError</B>()</PRE>
<DL>
<DD>Returns a description of the node that can make it easy to identify
in error messages (by default, at least its name and the tree it's found in).
It's okay if this is a reasonably expensive procedure -- it won't be called
a lot.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeLatexTree()"><!-- --></A><H3>
makeLatexTree</H3>
<PRE>
public java.lang.String <B>makeLatexTree</B>()</PRE>
<DL>
<DD>Produces the LaTeX code for a LaTeX tree of the subtree rooted at this node, using the <tt>epic</tt>
and <tt>fancybox</tt> packages, as described in sections 10.5.2 (page 307) 
and 10.1.3 (page 278) of <i>The LaTeX Companion</i>, respectively.  For this to
work, the output of toString() must not contain any weird latex characters, notably { or } or % or \,
unless you know what you're doing. See the documentation for ec.gp.GPTree for information
on how to take this code snippet and insert it into your LaTeX file.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRootedTree(ec.EvolutionState, int, int, int)"><!-- --></A><H3>
printRootedTree</H3>
<PRE>
public int <B>printRootedTree</B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                           int&nbsp;log,
                           int&nbsp;verbosity,
                           int&nbsp;printbytes)</PRE>
<DL>
<DD>Prints out the tree on a single line, with no ending \n, in a fashion that can
be read in later by computer. O(n).  
You should call this method with printbytes == 0.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRootedTree(ec.EvolutionState, java.io.PrintWriter, int)"><!-- --></A><H3>
printRootedTree</H3>
<PRE>
public int <B>printRootedTree</B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                           java.io.PrintWriter&nbsp;writer,
                           int&nbsp;printbytes)</PRE>
<DL>
<DD>Prints out the tree on a single line, with no ending \n, in a fashion that can
be read in later by computer. O(n).  Returns the number of bytes printed.
You should call this method with printbytes == 0.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRootedTreeForHumans(ec.EvolutionState, int, int, int, int)"><!-- --></A><H3>
printRootedTreeForHumans</H3>
<PRE>
public int <B>printRootedTreeForHumans</B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                                    int&nbsp;log,
                                    int&nbsp;verbosity,
                                    int&nbsp;tablevel,
                                    int&nbsp;printbytes)</PRE>
<DL>
<DD>Prints out the tree in a readable Lisp-like multi-line fashion. O(n).  You should call this method with tablevel and printbytes == 0.  No ending '\n' is printed.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readNode(ec.util.DecodeReturn)"><!-- --></A><H3>
readNode</H3>
<PRE>
public <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>readNode</B>(<A HREF="../../ec/util/DecodeReturn.html">DecodeReturn</A>&nbsp;dret)
                throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Reads the node symbol,
advancing the DecodeReturn to the first character in the string
beyond the node symbol, and returns a new, empty GPNode of the
appropriate class representing that symbol, else null if the
node symbol is not of the correct type for your GPNode class. You may
assume that initial whitespace has been eliminated.  Generally should
be case-SENSITIVE, unlike in Lisp.  The default
version usually works for "simple" function names, that is, not ERCs
or other stuff where you have to encode the symbol.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readRootedTree(int, ec.util.DecodeReturn, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int, ec.EvolutionState)"><!-- --></A><H3>
readRootedTree</H3>
<PRE>
public static <A HREF="../../ec/gp/GPNode.html">GPNode</A> <B>readRootedTree</B>(int&nbsp;linenumber,
                                    <A HREF="../../ec/util/DecodeReturn.html">DecodeReturn</A>&nbsp;dret,
                                    <A HREF="../../ec/gp/GPType.html">GPType</A>&nbsp;expectedType,
                                    <A HREF="../../ec/gp/GPFunctionSet.html">GPFunctionSet</A>&nbsp;set,
                                    <A HREF="../../ec/gp/GPNodeParent.html">GPNodeParent</A>&nbsp;parent,
                                    int&nbsp;argposition,
                                    <A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state)
                             throws java.lang.CloneNotSupportedException</PRE>
<DL>
<DD>Reads the node and its children from the form printed out by printRootedTree.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="eval(ec.EvolutionState, int, ec.gp.GPData, ec.gp.ADFStack, ec.gp.GPIndividual, ec.Problem)"><!-- --></A><H3>
eval</H3>
<PRE>
public abstract void <B>eval</B>(<A HREF="../../ec/EvolutionState.html">EvolutionState</A>&nbsp;state,
                          int&nbsp;thread,
                          <A HREF="../../ec/gp/GPData.html">GPData</A>&nbsp;input,
                          <A HREF="../../ec/gp/ADFStack.html">ADFStack</A>&nbsp;stack,
                          <A HREF="../../ec/gp/GPIndividual.html">GPIndividual</A>&nbsp;individual,
                          <A HREF="../../ec/Problem.html">Problem</A>&nbsp;problem)</PRE>
<DL>
<DD>Evaluates the node with the given thread, state, individual, problem, and stack.
Your random number generator will be state.random[thread].  
The node should, as appropriate, evaluate child nodes with these same items
passed to eval(...).

<p>About <b>input</b>: <tt>input</tt> is special; it is how data is passed between
parent and child nodes.  If children "receive" data from their parent node when
it evaluates them, they should receive this data stored in <tt>input</tt>.
If (more likely) the parent "receives" results from its children, it should
pass them an <tt>input</tt> object, which they'll fill out, then it should
check this object for the returned value.

<p>A tree is typically evaluated by dropping a GPData into the root.  When the
root returns, the resultant <tt>input</tt> should hold the return value.

<p>In general, you should not be creating new GPDatas.  
If you think about it, in most conditions (excepting ADFs and ADMs) you 
can use and reuse <tt>input</tt> for most communications purposes between
parents and children.  

<p>So, let's say that your GPNode function implements the boolean AND function,
and expects its children to return return boolean values (as it does itself).
You've implemented your GPData subclass to be, uh, <b>BooleanData</b>, which
looks like 

 <tt><pre>public class BooleanData extends GPData 
    {
    public boolean result;
    public GPData copyTo(GPData gpd)
      {
      ((BooleanData)gpd).result = result;
      }
    }</pre></tt>

<p>...so, you might implement your eval(...) function as follows:

 <tt><pre>public void eval(final EvolutionState state,
                     final int thread,
                     final GPData input,
                     final ADFStack stack,
                     final GPIndividual individual,
                     final Problem problem
    {
    BooleanData dat = (BooleanData)input;
    boolean x;

    // evaluate the first child
    children[0].eval(state,thread,input,stack,individual,problem);
  
    // store away its result
    x = dat.result;

    // evaluate the second child
    children[1].eval(state,thread,input,stack,individual,problem);

    // return (in input) the result of the two ANDed

    dat.result = dat.result && x;
    return;
    }
</pre></tt><DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../ec/gp/GPInitializer.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../ec/gp/GPNodeBuilder.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GPNode.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
